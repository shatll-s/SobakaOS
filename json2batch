#!/bin/bash

RIG_CFG="/dog/cfg/rig.cfg"
VARIABLES_CFG="/dog/service/variables"
AUTOSWITCH_TMP="/tmp/autoswitch"
[[ ! -z $2 ]] && BATCH_CFG=$2 || BATCH_CFG="/dog/cfg/batch.cfg"
. $VARIABLES_CFG
name=$(cat /etc/hostname)
manifest=`cat $1`

function convert_algo () { #for nicehash
	local input_algo=${1^^}
	case $input_algo in
		BEAMHASHII|BEAMHASH)
			local output_algo="BEAMV2"
		;;
		ETHASH)
			local output_algo="DAGGERHASHIMOTO"
		;;
		CRYPTONIGHT/0)
			local output_algo="CRYPTONIGHT"
		;;
		CRYPTONIGHT/1)
			local output_algo="CRYPTONIGHTV7"
		;;
		CNR|MONERO|CRYPTONIGHT/2)
			local output_algo="CRYPTONIGHTV8"
		;;
		CN_HEAVY|CRYPTONIGHT-HEAVY)
			local output_algo="CRYPTONIGHTHEAVY"
		;;
		CUCKAROO29)
			local output_algo="GRINCUCKAROO29"
		;;
		CUCKAROOM29)
			local output_algo="CUCKAROOM"
		;;
		EQUIHASH144_5)
			local output_algo="ZHASH"
		;;
		CUCKAROOD29)
			local output_algo="GRINCUCKAROOD29"
		;;
		CUCKOO29|AETERNITY)
			local output_algo="CUCKOOCYCLE" 
		;;
		CUCKATOO|CUCKATOO31)
			local output_algo="GRINCUCKATOO31"
		;;
		LYRA2V3)
			local output_algo="LYRA2REV3"
		;;
		*)
			local output_algo=$input_algo
		;;
	esac
	echo $output_algo	
}

function get_variables () {	
	#[[ `echo $manifest | jq ".miner"` != null ]]	&& miner=`echo $manifest | jq -r ".miner"`
	local manifest="$1"
	for option in miner coin wallet pass pool algo fork brand dual_wallet dual_pool dual_pass epools_type; do
		if [[ `echo $manifest | jq ".$option"` != null ]]; then
			option_value="`echo $manifest | jq -r \".$option\"`" #double slash, because eval open it
			eval "$option=\"$option_value\""
		fi
	done

	for option in template addition epools; do
		if [[ `echo $manifest | jq ".$option"` != null ]]; then
			option_value="`echo $manifest | jq -r \".$option\" | sed "s/\\\$WORKER/$name/" | sed "s/\\\$ADDRESS/$wallet/"`" #double slash, because eval open it
			eval "$option=\"$option_value\""
		fi
	done

	for option in dual_template; do
		if [[ `echo $manifest | jq ".$option"` != null ]]; then
			option_value="`echo $manifest | jq -r \".$option\" | sed "s/\\\$WORKER/$name/" | sed "s/\\\$ADDRESS/$dual_wallet/"`" #double slash, because eval open it
			eval "$option=\"$option_value\""
		fi
	done

	if [[ ! -z $epools && $epools_type == 2 ]]; then
		epools_arr=(`echo "$epools"`)
		IFS='-' read -ra add_array <<< "$addition"
	fi

	epools_str=""
	
	if [[ ! -z $pool ]]; then
		pool_without_port=`echo $pool | sed 's/\:[0-9][0-9]*$//'`
		port=`echo $pool | sed 's/.*://'`
	fi

	#21.02.2020 NEED TO DELETE LATER
	#[[ `echo $manifest | jq ".template"` != null ]]	&&
	#	template=`echo $manifest | jq -r ".template" | sed "s/\\\$WORKER/$name/" | sed "s/\\\$ADDRESS/$wallet/"`

	for option in config config_pools config_nvidia config_amd config_cpu; do
		if [[ `echo $manifest | jq ".$option"` != null ]]; then
			option_value="`echo $manifest | jq -r \".$option\" | sed 's/&#34;/\\\\"/g; s/&#39;/\\\\"/g; s/,\s*$//'`"
			#double slash, because eval open it. Also delete comma in the end
			[[ $option_value != {* && $option_value != *} ]] && option_value="{$option_value}"
			eval "$option=\"$option_value\""
		fi
	done
}

function make_batch () {
	[[ ! -z $fork ]] && miner_dir="/dog/miners/$miner/$fork/" || miner_dir="/dog/miners/$miner/"
	local minerexec="cd $miner_dir; " #some miners solvers, so let them do it in their dirs
	if [[ $miner == "ccminer" && $fork == "tpruvot-2.3.1" ]]; then
		:
	else
		minerexec+="${PREFIX[$miner]}" #prefix=EXPORT MEMORY_ALLOCATION......
	fi

	minerexec+="${miner_dir}miner" #now all miners need to have name "miner"
	
	case $miner in
		claymore)
			minerexec+=" -epool $pool"
			[[ ! -z $template ]]&& minerexec+=" -ewal $template"
			[[ ! -z $pass ]]	&& minerexec+=" -epsw $pass"
			[[ ! -z $dcri ]]	&& minerexec+=" -dcri $dcri"
			if [[ ! -z $epools ]]; then
				if [[ $epools_type == 2 ]]; then
					for ((i=0; i < ${#epools_arr[@]}; i++)); do
						epools_pool=`echo "${epools_arr[$i]}" | tr -d '\r\n'`
						epools_str+="POOL: $epools_pool"
						[[ ! -z $template ]]&& epools_str+=", WALLET: $template"
						[[ ! -z $pass ]]&& epools_str+=", PSW: $pass"
						
						for ((y=1; y < ${#add_array[@]}; y++)); do
							add=(`echo "${add_array[$y]}"`)
							epools_str+=", ${add[0]^^}"
							unset add[0]
							epools_str+=" ${add[@]}"
						done
						epools_str+="\n"
					done
				else
					epools_str="$epools"
				fi
				
			fi	
			echo -e "$epools_str" > "$miner_dir/epools.txt" #nullify file if no epools data		
			#dual is dead
				#[[ `echo $manifest | jq ".dual_template"` != null ]]&&
				#		dual_template=`echo $manifest | jq ".dual_template" | sed 's/\"//g'`
				#	[[ `echo $manifest | jq ".dualcoin"` != null ]]&& dualcoin=`echo $manifest | jq ".dualcoin"`
				#	[[ `echo $manifest | jq ".dcri"` != null ]]&& dcri=`echo $manifest | jq ".dcri"`

				#[[ ! -z $dual_template `echo $manifest | jq ".dual_template"` != null ]]&& minerexec+=" -dwal \$"${MINER}"_DUAL_TEMPLATE"
				#[[ ! -z $dualcoin `echo $manifest | jq ".dualcoin"` != null ]]&& minerexec+=" -dcoin \$"${MINER}"_DUALCOIN"
				#[[ ! -z $pass `echo $manifest | jq ".pass"` != null ]]		&& minerexec+=" -dpsw \$APASS"
				#[[ ! -z $dualcoin `echo $manifest | jq ".dualcoin"` != null ]]&& minerexec+=" -dpool \$APOOL:\$APORT"
			[[ $addition != *"-mpsw"* ]] && APIPORT[$miner]="-${APIPORT[$miner]}"
			[[ $addition != *"-mport"* ]] && minerexec+=" -mport ${APIPORT[$miner]}"
			minerexec+=" -r 1 -logfile /dog/log/"$miner"_noappend.log"
		;;
		phoenix)
			#./PhoenixMiner -pool ssl://eu1.ethermine.org:5555 -pool2 ssl://us1.ethermine.org:5555 -wal 0x008c26f3a2Ca8bdC11e5891e0278c9436B6F5d1E.Rig001
			[[ ! -z $pool ]]&& minerexec+=" -pool $pool"

			if [[ ! -z $epools ]]; then
				if [[ $epools_type == 2 ]]; then
					for ((i=0; i < ${#epools_arr[@]}; i++)); do
						epools_pool=`echo "${epools_arr[$i]}" | tr -d '\r\n'`
						epools_str+="POOL: $epools_pool"
						[[ ! -z $template ]]&& epools_str+=", WAL: $template"
						[[ ! -z $pass ]]&& epools_str+=", PSW: $pass"

						for ((y=1; y < ${#add_array[@]}; y++)); do
							add=(`echo "${add_array[$y]}"`)
							epools_str+=", ${add[0]^^}"
							unset add[0]
							epools_str+=" ${add[@]}"
						done
						epools_str+="\n"
					done
				else
					epools_str="$epools"
				fi
				echo -e "$epools_str" > "$miner_dir/epools.txt"
			fi

			[[ ! -z $template ]]&& minerexec+=" -wal $template"
			[[ ! -z $pass ]]&& minerexec+=" -pass $pass"
			[[ $addition != *"-cdmport"* ]] && minerexec+=" -cdmport ${APIPORT[$miner]}"
			minerexec+=" -log 1 -logfile /dog/log/phoenix.log"
		;;
		ewbf)
			raw_pool=$(echo `echo $manifest | jq -r ".pool"` | sed -s 's/:.*//')
			port=$(echo `echo $manifest | jq -r ".pool"` | sed -s 's/.*://')
			[[ ! -z $algo ]]&& minerexec+=" --algo $algo"
			minerexec+=" --server $raw_pool --port $port"
			[[ ! -z $template ]]&& minerexec+=" --user $template"
			[[ `echo $manifest | jq ".pass"` != null ]]		&& minerexec+=" --pass $pass"
			minerexec+=" --api 127.0.0.1:${APIPORT[$miner]} --logfile /dog/log/"$miner".log"
		;;
		bminer)
			#./bminer -uri ethash://DDXKDhq73GRM3hjh6uee57fJ3LS2ctNtyi.workername@$vg.blake2s.com:8888  -api 127.0.0.1:1880
			minerexec+=" -uri "
			[[ -z $algo || $algo == "equihash" ]]&& minerexec+="stratum" || minerexec+=$algo
			minerexec+="://"
			[[ ! -z $template ]]&& minerexec+=$template
			[[ ! -z $pass ]]	&& minerexec+=":"$pass
			minerexec+="@$pool"
			minerexec+=" -api 127.0.0.1:${APIPORT[$miner]} -logfile=/dog/log/"$miner".log -watchdog=false"
		;;
		ccminer)
			#minerexec+="$fork -o $pool"
			minerexec+=" -o $pool"
			[[ ! -z $template ]]&& minerexec+=" -u $template"
			[[ ! -z $algo ]]&& minerexec+=" -a $algo"
			[[ ! -z $pass ]]&& minerexec+=" -p $pass"
			minerexec+=" --api-bind 127.0.0.1:${APIPORT[$miner]}"
		;;
		sgminer)
			#minerexec+="$fork -o $pool"
			minerexec+=" -o $pool"
			[[ ! -z $template ]]&& minerexec+=" -u $template"
			[[ ! -z $algo ]]&& minerexec+=" -k $algo"
			[[ ! -z $pass ]]&& minerexec+=" -p $pass"
			minerexec+=" --api-listen --api-port ${APIPORT[$miner]}"
		;;
		ethminer)
			minerexec+=" -P"
			if [[ $pool != *://* ]]; then
				minerexec+=" stratum://"
				cleanpool=pool
			elif [[ $pool == *ssl://* ]]; then
				minerexec+=" stratum1+ssl://"
				cleanpool=`echo $pool | sed  's/^.*ssl:\/\///'`
			fi
			minerexec+="$template:$pass@$cleanpool" #USERNAME.WORKERNAME:WORKERPWD
			#echo $brand	
			minerexec+=" --farm-recheck 500 --report-hashrate --api-port ${APIPORT[$miner]} --HWMON 1 $brand"
		;;
		claymore_c)
			minerexec+=" -xpool $pool -xwal $template"
			[[ ! -z $pass ]]&& minerexec+=" -xpsw $pass"
			minerexec+=" -r 1 -mport -${APIPORT[$miner]} -logfile /dog/log/"$miner"_noappend.log"
		;;
		claymore_z)
			minerexec+=" -zpool $pool -zwal $template"
			[[ ! -z $pass ]]&& minerexec+=" -zpsw $pass"
			minerexec+=" -r 1 -mport -${APIPORT[$miner]} -logfile /dog/log/"$miner"_noappend.log"
		;;
		cpuminer)
			minerexec+=" -o "
			[[ $template != *://* ]]&& minerexec+="stratum+tcp://"
			minerexec+="$pool -u $template"
			[[ ! -z $algo ]]&& minerexec+=" -a $algo"
			[[ ! -z $pass ]]&& minerexec+=" -p $pass"
			minerexec+=" --api-bind 127.0.0.1:${APIPORT[$miner]}"
		;;
		t_rex)
			minerexec+=" -c config"
			#make config file
			dog_json=`cat "${miner_dir}config_global.json"` #it will be json based on global, but with user changes

			[[ ! -z $template ]]&& dog_json=`jq '.pools[0].user = $newvalue' --arg newvalue "$template" <<< $dog_json`
			[[ ! -z $pool ]]&& dog_json=`jq '.pools[0].url = $newvalue' --arg newvalue "$pool" <<< $dog_json`
			[[ ! -z $pass ]]&& dog_json=`jq '.pools[0].pass = $newvalue' --arg newvalue "$pass" <<< $dog_json`
			[[ ! -z $algo ]]&& dog_json=`jq '.algo = $newvalue' --arg newvalue "$algo" <<< $dog_json`

			#looking for keys in json
			if [[ $config != "{null}" ]]; then
				keys=(`echo $config | jq 'to_entries[].key' | jq -r '.'`) #keys in config, such as "devices", "log-path", e.t.c.
				for ((y=0; y < ${#keys[@]}; y++)); do
					#echo "Check ${keys[$y]}"
					[[ `echo $dog_json | jq ".\"${keys[$y]}\""` != null ]] &&
						dog_json=`jq "del(.\"${keys[$y]}\")" <<< "$dog_json"` #if key exist, delete it

					value=`echo $config | jq ".\"${keys[$y]}\""`
					dog_json=`jq ". + { \"${keys[$y]}\": $value }" <<< "$dog_json"`
				done
			fi	
				echo -e "$dog_json" | jq '.' > "${miner_dir}config"
		;;
		nanominer)
			minerexec+=" /dog/miners/nanominer/config.ini "
			config="logPath=/dog/log/nanominer.log\n"
			config+="port=9090\n"
			config+="mport=0\n"
			config+="rigName = $name\n"
			[[ ! -z $algo ]]&& config+="[$algo]\n"
			[[ ! -z $coin ]]&& config+="coin=$coin\n"
			config+="wallet = $wallet\n"
			config+="pool1 = $pool\n"
			[[ ! -z $pass ]]&& config+="rigPassword = $pass\n"
			[[ ! -z $addition ]]&& config+="$addition"

			mkdir -p /dog/miners/nanominer
			echo -e "$config" > /dog/miners/nanominer/config.ini
		;;
		lolminer)
			#lolMiner.exe --coin BEAM --pool beam-eu.leafpool.com --port 3333 --user wallet.name
			[[ ! -z $algo ]]&& minerexec+=" --coin $algo"
			[[ ! -z $pool_without_port ]]&& minerexec+=" --pool $pool_without_port"
			[[ ! -z $port ]]&& minerexec+=" --port $port"
			[[ ! -z $pass ]]&& minerexec+=" --pass $pass"
			[[ ! -z $template ]]&& minerexec+=" --user $template"
			minerexec+=" --apiport ${APIPORT[$miner]}"
		;;
		gminer)
			#lolMiner.exe --coin BEAM --pool beam-eu.leafpool.com --port 3333 --user wallet.name
			[[ ! -z $algo ]]&& minerexec+=" --algo $algo"
			[[ ! -z $pool_without_port ]]&& minerexec+=" --server $pool_without_port"
			[[ ! -z $port ]]&& minerexec+=" --port $port"
			[[ ! -z $template ]]&& minerexec+=" --user $template"
			[[ ! -z $pass ]]&& minerexec+=" --pass $pass"
			[[ `echo $pool | grep -c "nicehash"` -eq 1 ]] &&  minerexec+=" --proto stratum"

			[[ ! -z $dual_pool ]]&& minerexec+=" --dserver $dual_pool"
			[[ ! -z $dual_template ]]&& minerexec+=" --duser $dual_template"
			[[ ! -z $dual_pass ]]&& minerexec+=" --dpass $dual_pass"
			[[ `echo $dual_pool | grep -c "nicehash"` -eq 1 ]] &&  minerexec+=" --dproto stratum"
			minerexec+=" --api ${APIPORT[$miner]} --logfile /dog/log/gminer.log"
		;;
		xmrig_cpu|xmrig_new)
			[[ ! -z $algo ]]&& minerexec+=" -a $algo"
			[[ ! -z $pool ]]&& minerexec+=" -o $pool"
			[[ ! -z $template ]]&& minerexec+=" -u $template"
			[[ ! -z $pass ]]&& minerexec+=" -p $pass"
			minerexec+=" --http-enabled --http-port ${APIPORT[$miner]}"
		;;
		xmrig*)
			[[ ! -z $algo ]]&& minerexec+=" -a $algo"
			[[ ! -z $pool ]]&& minerexec+=" -o $pool"
			[[ ! -z $template ]]&& minerexec+=" -u $template"
			[[ ! -z $pass ]]&& minerexec+=" -p $pass"
			minerexec+=" --api-port ${APIPORT[$miner]}"
		;;
		z_enemy)
			[[ ! -z $algo ]]&& minerexec+=" -a $algo"
			[[ ! -z $pool ]]&& minerexec+=" -o $pool"
			[[ ! -z $template ]]&& minerexec+=" -u $template"
			[[ ! -z $pass ]]&& minerexec+=" -p $pass"
			minerexec+=" --api-bind=${APIPORT[$miner]} --log=/dog/log/z_enemy.log"
		;;
		xmr_stak)
			minerexec+=" -c ${miner_dir}config.txt -C ${miner_dir}pools.txt"
			for config_name in config.txt pools.txt nvidia.txt amd.txt cpu.txt; do
				[[ -f "${miner_dir}${config_name}" ]] && rm "${miner_dir}${config_name}"
			done
			#pools.txt section
				pool_json=$(
					jq -n \
					--arg pool_address "$pool" \
					--arg wallet_address "$wallet" \
					--arg rig_id "$name" \
					--arg pool_password "$pass" \
					--arg tls_fingerprint "" \
					'{
						$pool_address, $wallet_address,	$rig_id, $pool_password, $tls_fingerprint
					}'
				)
				[[ $pool == *nicehash* ]] && use_nicehash=true || use_nicehash=false
				pool_json=`jq ". + { \"use_nicehash\": $use_nicehash }" <<< "$pool_json"`
				pool_json=`jq ". + { \"use_tls\": false }" <<< "$pool_json"`
				pool_json=`jq ". + { \"pool_weight\": 1 }" <<< "$pool_json"`

				#looking for keys in json
				if [[ $config_pools != "{null}" ]]; then
					keys=(`echo $config_pools | jq 'to_entries[].key' | jq -r '.'`) #keys in config, such as "devices", "log-path", e.t.c.
					for ((y=0; y < ${#keys[@]}; y++)); do
						[[ `echo $pool_json | jq ".\"${keys[$y]}\""` != null ]] &&
							pool_json=`jq "del(.\"${keys[$y]}\")" <<< "$pool_json"` #if key exist, delete it

						value=`echo $config_pools | jq ".\"${keys[$y]}\""`
						pool_json=`jq ". + { \"${keys[$y]}\": $value }" <<< "$pool_json"`
					done
				fi	
				
				pools_txt="\"pool_list\" :\n["`echo -e "$pool_json" | jq '.'`"],\n\"currency\" : \"$algo\""
				echo -e "$pools_txt" > $miner_dir/pools.txt
			#end of pool.txt section

			#config.txt section
				config_txt="{"`cat "$miner_dir/global_config.cfg"`"}" #it will be based on global, but with user changes

				#looking for keys in json
				if [[ $config != "{null}" ]]; then
					keys=(`echo $config | jq 'to_entries[].key' | jq -r '.'`) #keys in config, such as "devices", "log-path", e.t.c.
					for ((y=0; y < ${#keys[@]}; y++)); do
						[[ `echo $config_txt | jq ".\"${keys[$y]}\""` != null ]] &&
							config_txt=`jq "del(.\"${keys[$y]}\")" <<< "$config_txt"` #if key exist, delete it

						value=`echo $config | jq ".\"${keys[$y]}\""`
						config_txt=`jq ". + { \"${keys[$y]}\": $value }" <<< "$config_txt"`
					done
				fi	
				echo -e "$config_txt" | jq '.' | sed '/[{}]/d; s/^\s*//g' > "$miner_dir/config.txt"
			#end of config.txt section

			#nvidia.txt, amd.txt, cpu.txt section
				[[ ! -z $config_nvidia ]] && echo -e "$config_nvidia" | jq '.' | sed '/[{}]/d; s/^\s*//g' > "$miner_dir/nvidia.txt"
				[[ ! -z $config_amd ]] && echo -e "$config_amd" | jq '.' | sed '/[{}]/d; s/^\s*//g' > "$miner_dir/amd.txt"
				[[ ! -z $config_cpu ]] && echo -e "$config_cpu" | jq '.' | sed '/[{}]/d; s/^\s*//g' > "$miner_dir/cpu.txt"
			#end of nvidia.txt, amd.txt, cpu.txt section
		;;
		wildrig_multi)
			#./wildrig-multi --algo algo --opencl-threads auto --opencl-launch auto --url pool:port --user wallet --pass password
			[[ ! -z $algo ]]&& minerexec+=" -a $algo"
			[[ ! -z $pool ]]&& minerexec+=" -o $pool"
			[[ ! -z $template ]]&& minerexec+=" -u $template"
			[[ ! -z $pass ]]&& minerexec+=" -p $pass"
			minerexec+=" --api-port=${APIPORT[$miner]} --log-file=/dog/log/wildrig.log"
		;;
		teamredminer)
			#./teamredminer -a phi2 -o stratum+tcp://lux.pickaxe.pro:8332 -u LhreQGewLdoGFiqq882Am6i644Qc1h28Wh
			[[ ! -z $algo ]]&& minerexec+=" -a $algo"
			if [[ ! -z $pool ]]; then
				[[ `echo $pool | grep -c "://"` -eq 0 ]] && pool="stratum+tcp://$pool"
				minerexec+=" -o $pool"
			fi
			[[ ! -z $template ]]&& minerexec+=" -u $template"
			[[ ! -z $pass ]]&& minerexec+=" -p $pass"
			minerexec+=" --api_listen=${APIPORT[$miner]} --log_file=/dog/log/teamredminer.log --bus_reorder"
		;;
		cryptodredge)
			#./teamredminer -a phi2 -o stratum+tcp://lux.pickaxe.pro:8332 -u LhreQGewLdoGFiqq882Am6i644Qc1h28Wh
			[[ ! -z $algo ]]&& minerexec+=" -a $algo"
			[[ ! -z $pool ]]&& minerexec+=" -o $pool"
			[[ ! -z $template ]]&& minerexec+=" -u $template"
			[[ ! -z $pass ]]&& minerexec+=" -p $pass"
			minerexec+=" --api-bind ${APIPORT[$miner]} --log /dog/log/cryptodredge.log"
		;;
		nbminer)
			#./nbminer -a ethash -o ethproxy+tcp://eth.f2pool.com:8008 -u 0x4296116d44a4a7259B52B1A756e19083e675062A.default -log
			if [[ ! -z $pool && `echo $pool | grep -c "://"` -eq 0 ]]; then
				[[ `echo $pool | grep -c "nicehash"` -eq 1 ]] && pool="nicehash+tcp://$pool" || pool="stratum+tcp://$pool"
			fi
			if [[ ! -z $dual_pool && `echo $dual_pool | grep -c "://"` -eq 0 ]]; then
				[[ `echo $dual_pool | grep -c "nicehash"` -eq 1 ]] && dual_pool="nicehash+tcp://$dual_pool" || dual_pool="stratum+tcp://$dual_pool"
			fi
				
			if [[ ! -z $algo ]]; then
				minerexec+=" -a $algo"
				if [[ $algo == *"_ethash" ]]; then
					#main and dual are reverted
					[[ ! -z $dual_pool ]]&& minerexec+=" -o $dual_pool"
					[[ ! -z $dual_template ]]&& minerexec+=" -u $dual_template"
					[[ ! -z $dual_pass ]]&& minerexec+=":$dual_pass"

					[[ ! -z $pool ]]&& minerexec+=" -do $pool"
					[[ ! -z $template ]]&& minerexec+=" -du $template"
					[[ ! -z $pass ]]&& minerexec+=":$pass"
				else
					[[ ! -z $pool ]]&& minerexec+=" -o $pool"
					[[ ! -z $template ]]&& minerexec+=" -u $template"
					[[ ! -z $pass ]]&& minerexec+=":$pass"
				fi
			fi
			
			minerexec+=" --api 127.0.0.1:${APIPORT[$miner]} --log" #log in miner folder :(
		;;
		ttminer)
	  		[[ ! -z $algo ]]&& minerexec+=" -a $algo"
			[[ ! -z $coin ]]&& minerexec+=" -coin $coin"
			[[ ! -z $pool ]]&& minerexec+=" -o $pool"
			[[ ! -z $wallet ]]&& minerexec+=" -u $wallet"
			[[ ! -z $pass ]]&& minerexec+=" -p $pass"
			[[ ! -z $name ]]&& minerexec+=" -w $name"
			minerexec+=" --api-bind 127.0.0.1:${APIPORT[$miner]} --log"
		;;	
		qitmeer)
	  		[[ ! -z $algo ]]&& minerexec+=" --pow=$algo"
			[[ ! -z $coin ]]&& minerexec+=" --symbol=$coin"
			[[ ! -z $pool ]]&& minerexec+=" -o $pool"
			[[ ! -z $template ]]&& minerexec+=" -m $template"
			[[ ! -z $pass ]]&& minerexec+=" -n $pass"
			minerexec+=" --stats_server=127.0.0.1:${APIPORT[$miner]} --log_level=info --minerlog=/dog/log/qitmeer.log"
		;;
		sushiminer)
			dog_json=$(
				jq -n \
				--arg address "$wallet" \
				--arg host "$pool" \
				--arg port "$port" \
				--arg name "$name" \
				'{
					$address, $host, $port, $name
				}'
			)

			#looking for keys in json
			if [[ $config != "{null}" ]]; then
				keys=(`echo $config | jq 'to_entries[].key' | jq -r '.'`) #keys in config, such as "devices", "log-path", e.t.c.
				for ((y=0; y < ${#keys[@]}; y++)); do
					#echo "Check ${keys[$y]}"
					[[ `echo $dog_json | jq ".\"${keys[$y]}\""` != null ]] &&
						dog_json=`jq "del(.\"${keys[$y]}\")" <<< "$dog_json"` #if key exist, delete it

					value=`echo $config | jq ".\"${keys[$y]}\""`
					dog_json=`jq ". + { \"${keys[$y]}\": $value }" <<< "$dog_json"`
				done
			fi	
				echo -e "$dog_json" | jq '.' > "${miner_dir}miner.conf"


	  		
		;;
		miniz)
	  		[[ ! -z $algo ]]&& minerexec+=" --par=$algo"
			[[ ! -z $coin ]]&& minerexec+=" --symbol=$coin" || minerexec+=" --smart-pers"
			[[ ! -z $pass ]]&& minerexec+=" -p $pass"
			[[ ! -z $pool && ! -z $template ]]&&  minerexec+=" --url=$template@$pool"
			
			minerexec+=" --telemetry=${APIPORT[$miner]} --log-file=/dog/log/miniz.log"
		;;
		srbminer)
			[[ ! -z $pool ]]&& minerexec+=" --pool $pool"
			[[ `echo $pool | grep -c "nicehash"` -eq 1 ]] && pool=" --nicehash true"
			#echo "@"$template"@"
			[[ ! -z $template ]]&& minerexec+=" --wallet $template"
			#[[ ! -z $name ]]&& minerexec+=" --worker $name"
			[[ ! -z $pass ]]&& minerexec+=" --password $pass"
			[[ ! -z $algo ]]&& minerexec+=" --algorithm $algo"

			
			minerexec+=" --api-enable --api-port ${APIPORT[$miner]} --enable-opencl-cleanup --log-file=/dog/log/srbminer.log"
		;;	
		*)
			: #do nothing
		;;
	esac
	[[ ! -z $addition && $miner != "nanominer" ]] && minerexec+=" $addition"
	echo $minerexec
}
############################################### START HERE
#Help command
if [[ ! -z $1 ]]; then
	if [[ -f $1 ]]; then # "First operand is link to json file..."
		if [[ -z $(jq -e . >/dev/null 2>&1 <<< "$manifest") && $? != 0 ]]; then
			basename=`basename $0`
			echo "$basename: first operand is path to invalid json file. Exiting"
			exit 1
		fi
	else
		basename=`basename $0`
		echo "$basename: first operand is not a path to valid json. Exiting"
		exit 1
	fi
else
	basename=`basename $0`
	echo "$basename: missing operand"
	echo -e "You need to put path to json file as first operand"
	exit 1
fi

case $2 in
	return)
		get_variables "$manifest"
		echo `make_batch`
	;;
	*)
		miner_i=$(echo $1 | sed 's/\/tmp\/batch//')
		if [[ ! -z $manifest ]]; then
			get_variables "$manifest"
			#WD section

			if [[ $(echo $manifest | jq '.wd.wd_hr') != '""' && $(echo $manifest | jq '.wd.wd_hr') != 'null' ]]; then
				if (cat $RIG_CFG | grep -qc "WD_HR="); then 
					sed -i "/.*WD_HR=.*/d" $RIG_CFG
				fi
				echo "WD_HR='"$(echo $manifest | jq '.wd.wd_hr')"'" >> $RIG_CFG
			fi

			if [[ $(echo $manifest | jq '.wd.wd_enabled') != '""' && $(echo $manifest | jq '.wd.wd_enabled') != 'null' ]]; then
				if (cat $RIG_CFG | grep -qc "WD_ENABLED="); then 
					sed -i "/.*WD_ENABLED=.*/d" $RIG_CFG
				fi
				echo "WD_ENABLED="$(echo $manifest | jq -r '.wd.wd_enabled') >> $RIG_CFG

				#WD_MINER restart time
				if [[ $(echo $manifest | jq '.wd.wd_restart') != '""' && $(echo $manifest | jq '.wd.wd_restart') != 'null' ]]; then
					wd_restart=$(echo $manifest | jq -r '.wd.wd_restart')
				else
					wd_restart=3
				fi
				[[ $(cat $RIG_CFG | grep -c "WD_RESTART=") -gt 0 ]] && sed -i "/.*WD_RESTART=.*/d" $RIG_CFG
				echo "WD_RESTART="$wd_restart >> $RIG_CFG
				#WD_REBOOT restart time
				if [[ $(echo $manifest | jq '.wd.wd_reboot') != '""' && $(echo $manifest | jq '.wd.wd_reboot') != 'null' ]]; then
					wd_reboot=$(echo $manifest | jq -r '.wd.wd_reboot')
				else
					wd_reboot=5
				fi
				[[ $(cat $RIG_CFG | grep -c "WD_REBOOT=") -gt 0 ]] && sed -i "/.*WD_REBOOT=.*/d" $RIG_CFG
				echo "WD_REBOOT="$wd_reboot >> $RIG_CFG
			fi
			
			[[ `echo $manifest | jq ".autoswitch"` != null ]] && autoswitch_arr=`echo $manifest | jq ".autoswitch"`
			if [[ -z $autoswitch_arr ]]; then
				echo "No autoswitch detected"
				if [[ ! -z $miner ]]; then
					/dog/getminer $miner $fork
				fi
				batch=`make_batch`
				[[ $miner_i -eq 1 ]] && asw stop

			else
				batch=`make_batch`
				echo "Autoswitch detected"
				algo=`convert_algo $algo`
				json=$(
					jq -n \
					--arg algo "$algo" \
					--arg miner "$miner" \
					--arg batch "$batch" \
					'{ autoswitch: [ {
						$algo,
						$miner,
						$batch}]
					}'
				)
				
				for (( i=0; i < `echo $autoswitch_arr | jq 'length'`; i++ )); do
					unset miner batch coin pass pool addition algo fork brand config config_pools config_nvidia config_amd config_cpu pool_without_port port batch #don`t delete template && wallet (it`s same in NiceHash)
					autoswitch=`echo $autoswitch_arr | jq ".[$i]"`
					get_variables "$autoswitch"
					#[[ $miner == "t_rex" ]] && echo "*** We need to download T-Rex miner for AutoSwitch right now because we need to edit included config file ***" && /dog/getminer $miner $fork 
					/dog/getminer $miner $fork #not optimal - need to download all miners at start
					batch=`make_batch`
					algo=`convert_algo $algo`
					json=`echo $json | jq ".autoswitch += [{\"algo\": \"$algo\", \"miner\": \"$miner\", \"batch\": \"$batch\"}]"`
				done
				echo $json | jq '.' > $AUTOSWITCH_TMP
				#miner="" #this is to empty batch.cfg
				#batch="" #this is to empty batch.cfg
				asw restart
			fi

		fi
			
		if [[ -z $autoswitch_arr ]]; then
			[[ -f $BATCH_CFG ]] && sed -i "/.*batch$miner_i=.*/d" $BATCH_CFG
			[[ -f $BATCH_CFG ]] && sed -i "/.*miner$miner_i=.*/d" $BATCH_CFG
			echo "batch$miner_i=\"$batch\"" >> $BATCH_CFG
			echo "miner$miner_i=\"$miner\"" >> $BATCH_CFG
			echo "$(date --rfc-3339=seconds) Batch $miner_i config is now wrote in $BATCH_CFG"
		else
			echo "$(date --rfc-3339=seconds) No changes wrote in $BATCH_CFG (AutoSwitch will do it)"
		fi
	;;
esac
