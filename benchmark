#!/bin/bash
BENCHMARK_CFG="/tmp/benchmark"
BATCH_CFG="/sobaka/cfg/batch.cfg"
RIG_CFG="/sobaka/cfg/rig.cfg"
LOCK_FILE="/tmp/.benchmark.lock"
LOG="/sobaka/log/benchmark.log"
VARIABLES_CFG="/sobaka/service/variables"
. $VARIABLES_CFG
[ -t 1 ] && . colors

#exec &>>$LOG

[ -t 1 ] && . colors

function echo2 () {
	echo -e "$1"
	#echo "$1" | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" >> $LOG
	echo "$1" | sed -e "s/\\\t/   /g; s/\\\e\[[0-9;]*m[0-9]*//g" >> $LOG
}

function displaytime () {
	local T=$1
	local D=$((T/60/60/24))
	local H=$((T/60/60%24))
	local M=$((T/60%60))
	local S=$((T%60))
	[[ $D > 0 ]] && printf '%d days ' $D
	[[ $H > 0 ]] && printf '%d hours ' $H
	[[ $M > 0 ]] && printf '%d min ' $M
	#[[ $D > 0 || $H > 0 || $M > 0 ]] && printf 'and '
	printf '%d sec\n' $S
}

function screen_check () {
	[[ $(screen -ls | grep -c "$1")  > 0 ]]&& echo $(screen -ls | grep -c "$1") || echo "0"
}

function check_con () {
	while true; do
  		for con in `netstat -anp | grep TIME_WAIT | grep ${APIPORT[$1]} | awk '{print $5}'`; do
			killcx $con lo $?>/dev/null
  		done
		netstat -anp | grep TIME_WAIT | grep ${APIPORT[$1]} &>/dev/null &&
			continue ||
			break
	done
}

function services_stop () {
	echo -e "${GREEN}> Stopping services${WHITE}"
	wd stop > /dev/null 2>&1
	systemctl stop sobaka
	if [[ $(screen_check asw) -gt 0 ]]; then
		echo 1 > /tmp/asw_trigger
		screen_kill asw
	fi	
}

function services_start () {
	echo -e "${GREEN}> Starting services${WHITE}"
	systemctl start sobaka
	systemctl start sobaka-wd
	[[ -f /tmp/asw_trigger && `cat /tmp/asw_trigger` -eq 1 ]] && asw restart
}

function send_data () {
	local data="$1"
	local request=$(
		jq -n \
		--arg password "$PASSWD" \
		--argjson benchmark "$data" \
		'{	
			"method": "benchmark",
			"jsonrpc": "2.0",
			"stats": {
				$password,
				$benchmark
			}
		}'

	)
	local response=$(echo $request | curl -s --data @- \
		--connect-timeout 7 --max-time 15 \
		"${HOST}?id=${RIG_ID}&method=benchmark" -H "Content-Type: application/json; charset=utf-8\r\n")
	echo "$response"
}


function benchmark () {
	data='{}' #nullify json
	for ((i=0; i < ${#algos[@]}; i++)); do
		echo2 "----------------------------------------------------------------"
		local algo=`echo $cfg | jq ".algo.${algos[$i]}"`
		echo $algo > /tmp/bm_current_algo
		local miner=`echo $cfg | jq -r ".algo.${algos[$i]}.miner"`
		local batch=`json2batch /tmp/bm_current_algo "return"`
		local check_time=`echo $time_array | jq -r ".${algos[$i]}"`
		local warm_up=`echo $warmup_array | jq -r ".${algos[$i]}"`
		[[ -z $check_time ]] && check_time=300
		[[ -z $warm_up ]] && warm_up=60
		echo2 "Algo: ${CYAN}${algos[$i]}${WHITE}\tminer: ${CYAN}$miner${WHITE}\tcheck${CYAN} $check_time${WHITE}\twarm-up${CYAN} $warm_up${WHITE}"
		echo -e "miner1=\"$miner\"\nbatch1=\"$batch\"" > $BATCH_CFG
		#check_con $miner
		screen -dmS miner1.benchmark bash -c "miner-loop $miner \"$batch\""
		sleep $warm_up
		echo2 "$warm_up seconds warm-up passed, start checking hashrate"
		local now=`date +%s`
		local stop_time=$((now + check_time))
		local iterations=0
		local hr_sum=0
		while [[ `date +%s` -le $stop_time ]]; do
			((iterations++))
			local stats=`sobaka-stats $miner`
			[[ `echo $stats | jq '.miner_total_hr'` != null ]] && local hr=`echo $stats | jq -r '.miner_total_hr'` ||
				local hr=0
			if [[ "phoenix claymore ethminer" == *$miner* ]]; then
				hr=`echo "scale=2; $hr / 1000" | bc -l`
			elif [[ "X16R" == *${algos[$i]^^}* ]]; then
				hr=`echo "scale=2; $hr / 1000000" | bc -l`
			fi
			hr_sum=`echo "scale=2; $hr_sum + $hr" | bc -l`
			echo -n '.'
			echo -n '.' >> $LOG
			sleep $sleep
		done
		local average_hr=`echo "scale=2; $hr_sum / $iterations" | bc -l`
		data=$(jq -n --arg algos "$data" \
			--arg key "${algos[$i]}" \
			--arg value "$average_hr" \
			'$algos | fromjson + { ($key) : ($value)}')
		screen_kill miner1.benchmark
		#echo $data
		local response=`send_data "$data"`
		echo2 "\nAverage hashrate on ${CYAN}${algos[$i]}${WHITE}:${GREEN} $average_hr${WHITE}"
		if [[ $notifications -eq 1 && `echo "$i+1" | bc -l` -lt ${#algos[@]} ]]; then
			time_stop=`date +%s`
			let "time=time_stop - time_start"
			hr_time=`displaytime time`
			proc=`echo "scale=0; ($i+1) * 100 / ${#algos[@]}" | bc -l`
			[[ $response == "Data received" ]] && msg "Benchmark $proc%" info "$(date --rfc-3339=seconds) Benchmark is NOT ended.\nNew benchmark values sent:\n$data\n$hr_time passed." ||
				msg "Benchmark $proc%" warning "$(date --rfc-3339=seconds) Benchmark is NOT ended.\nSomething goes wrong while sending stats to server.\n$hr_time passed."
		fi
	done
}

function main () {
	. $RIG_CFG
	services_stop
	sleep=5
	notifications=1
	cp $BATCH_CFG /tmp/benchmark_batch
	if [[ `echo $cfg | jq ".algo"` != null ]]; then
		algos=(`echo $cfg | jq -r ".algo | keys_unsorted[]"`)
	else
		echo -e "${RED}No algos given, exiting${WHITE}"
		rm $LOCK_FILE
		exit 1
	fi
	[[ `echo $cfg | jq ".time"` != null ]]	&& time_array=`echo $cfg | jq ".time"`
	[[ `echo $cfg | jq ".warmup"` != null ]]	&& warmup_array=`echo $cfg | jq ".warmup"`
	[[ `echo $cfg | jq ".notifications"` != null ]]	&& notifications=1 || notifications=0
	[[ $notifications -eq 1 ]] && msg "Benchmark started" info "$(date --rfc-3339=seconds) Benchmark started"
	echo2 "${GREEN}> Benchmark started at $(date --rfc-3339=seconds)${WHITE}"
	echo2 "Interval: ${CYAN}$sleep${WHITE}\t notifications:${CYAN} $notifications${WHITE}"
	
	benchmark
	cp /tmp/benchmark_batch $BATCH_CFG

	services_start
	time_stop=`date +%s`
	let "time=time_stop - time_start"
	hr_time=`displaytime time`

	try=0

	while [[ $try -lt 3 ]]; do
		local response=`send_data "$data"`
		echo "Response: $response"
		if [[ $response == "Data received" ]]; then
			msg "Benchmark config" info "$(date --rfc-3339=seconds) New benchmark values sent:\n$data\nBenchmark takes $hr_time" 
			rm $LOCK_FILE
			exit 0
		fi
		sleep 5
		((try++))	
	done
	#if we doesn`t send
	msg "Benchmark completed" warning "$(date --rfc-3339=seconds) Benchmark is ended, but something goes wrong while sending stats to server.\nTry to edit values manually:$data\n$hr_time passed."
}

case $1 in
	test)
        . $RIG_CFG
        data='{"Beamv2": "0","DaggerHashimoto": "0"}'
		data2='
			{
			 "CryptoNightv7": "5525.48",
			 "CryptoNightv8": "2510.71",
			 "CryptoNightHeavy": "5371.57",
			 "Beamv2": "87.91",
			 "DaggerHashimoto": "141.42",
			 "Lyra2rev3": "241.26",
			 "X16r": "58.47"
			}
		'
        request=$(
        jq -n \
        --arg password "$PASSWD" \
        --argjson benchmark "$data2" \
        '{      
                "method": "benchmark",
                "jsonrpc": "2.0",
                "stats": {
                        $password,
                        $benchmark
                }
        }'
		)
    echo $request | jq '.' -c

    response=$(echo $request | curl -s --data @- \
    --connect-timeout 7 --max-time 15 \
    "${HOST}?id=${RIG_ID}&method=benchmark" -H "Content-Type: application/json; charset=utf-8\r\n")
    echo $response
	;;
	show|"")
		screen -d benchmark
		screen -r benchmark
    ;;
	stop)
		screen_kill benchmark
		screen_kill miner1.benchmark
		screen_kill miner2.benchmark
		services_start
		[[ -f $BATCH_CFG ]] && cp /tmp/benchmark_batch $BATCH_CFG
		[[ -f $LOCK_FILE ]] && rm $LOCK_FILE
	;;
	log)
		[[ -f $LOG ]] && cat $LOG || echo "Benchmark log is not available"
	;;
	start_cli)
		time_start=`date +%s`
		rm -f $LOG #only last log will be available
		if  [[ -e $LOCK_FILE ]]; then
			pid=`cat $LOCK_FILE`
			ps --pid $pid &>/dev/null
			[[ $? == 0 ]] && echo -e "${RED}It seems another copy of Benchmark is already running\nCooldown a bit :)${WHITE}" && exit 1
		fi
		echo $$ > $LOCK_FILE
		
		if [[ ! -z $2 ]]; then
			echo -e "${GREEN}> Benchmark config given in arguments${WHITE}"
			cfg="$2"
		else
			if [[ ! -f $BENCHMARK_CFG ]]; then
				echo -e "${RED}$(date --rfc-3339=seconds) configuration file $BENCHMARK_CFG does not exist, exiting${WHITE}"
				rm $LOCK_FILE
				exit 1
			fi
			echo -e "${GREEN}> Read benchmark config from $BENCHMARK_CFG${WHITE}"
			cfg=`cat $BENCHMARK_CFG`
		fi
		main

		rm $LOCK_FILE
	;;
	start)
		if  [[ -e $LOCK_FILE ]]; then
			pid=`cat $LOCK_FILE`
			ps --pid $pid &>/dev/null
			[[ $? == 0 ]] && echo -e "${RED}It seems another copy of Benchmark is already running\nCooldown a bit :)${WHITE}" && exit 1
		fi
		echo $$ > $LOCK_FILE

		screen -dmS benchmark bash -c "benchmark start_cli"
		rm $LOCK_FILE
	;;
	--help|-h|*)
		bname=`basename $0`
		echo -e "Usage: ${CYAN}$bname [--help]${WHITE}"
	;;
esac
